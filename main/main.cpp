
#include "f.cpp"
#include <iostream>

//int hello(int x);1-5
static int hello(int x)//6
{
	return x;
}

int main()
{
   std::cout<<hello(5);/*1.выдаёт ошибку потому что метод объявлен но не определён и копилятон не знает что с ним делать
   3.в файле f.cpp и в main.cpp 2 функции int hello(int x) которые не определены и компилятор не знает что делать 
   4.ошибок нет но при компиляции только main.cpp  выдаёт ошибку потому что компилятор не может найти определение функции hello.
   5.выдаст ошибку так как функция с модификатором static имеет локальную область видимости и не может быть использована в других файлах.
   6.Теперь код будет успешно скомпилирован, так как функция hello определена в том же файле, в котором она используется, и имеет модификатор static, который делает ее локальной для данного файла.
   7.Если объявить функцию hello с модификатором static и определить ее в файле main.cpp, то компилятор создаст единственное определение функции в пределах файла main.cpp.
   Однако, если вы определите функцию hello без модификатора static в файле f.cpp, то компилятор создаст отдельное определение функции в файле f.cpp.
   Это значит, что будет две копии тела функции hello: одна в main.cpp и одна в f.cpp.
   */
}
//int hello(int x)//2.тепепь метод определём и ошибок не возникает 
//{
//	return x;
//}

